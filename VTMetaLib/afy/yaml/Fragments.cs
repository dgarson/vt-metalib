using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using YamlDotNet.Serialization;

namespace VTMetaLib.afy.yaml
{
    public class FragmentVarDefinition
    {
        [YamlMember(Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// A basic string value
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Allows inline resolution of properties that would be available in a rendered Go template, but is defined at this `Vars` level within the meta
        /// rather than within the imported fragment
        /// </summary>
        public string ValueRef { get; set; }

        /// <summary>
        /// Allows inline list definition for use in templating variables.
        /// 
        /// NOTE: this is NOT to be confused with a UtilityBelt `list` object or anything that would exist in the generated `met` file itself.
        /// </summary>
        public List<string> ValueList { get; set; }
    }


    #region Meta Fragments
    public class MetaFragmentDefinition : AfyStateContainer
    {
        /// <summary>
        /// Logical name for this meta fragment, must be unique across all meta and state fragments imported into the parent meta/afy
        /// </summary>
        [YamlMember(Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Optional prefix prepended to every state generated by this Meta Fragment
        /// </summary>
        [YamlMember(Order = 2)]
        public string StateNamePrefix { get; set; } = "";

        /// <summary>
        /// If the group of states / the encapsulated logic requires meta-level variable initialization, then a state name can be provided in this
        /// field, and assuming that the top-level MetaDefinition has an `InitState` defined, this state will be called one time only when the meta
        /// starts.
        /// 
        /// NOTE:
        /// This state *MUST* eventually reach the last rule which is managed by the `InitState` generation process, which will append a file rule to
        /// the `FragmentInitState` to `SetState` to the next `InitState`
        /// </summary>
        [YamlMember(Order = 3)]
        public string FragmentInitState { get; set; } = "";

        /// <summary>
        /// List of complete Meta States that will be imported into the parent meta/afy
        /// </summary>
        [YamlMember(Order = 4)]
        public List<AfyState> States { get; set; } = new List<AfyState>();

        /// <summary>
        /// Importable state fragments that can be used when this meta fragment is imported into a meta/afy
        /// </summary>
        [YamlMember(Order = 5)]
        public List<StateFragmentSectionDefinition> StateSections { get; set; } = new List<StateFragmentSectionDefinition>();

        /// <summary>
        /// optional list of named nav routes that can be referenced in any `EmbedNav` Action.
        /// </summary>
        [YamlMember(Order = 6)]
        public List<AfyNavRouteDefinition> NavRoutes { get; set; } = new List<AfyNavRouteDefinition>();

        public IList<AfyState> GetStates(AfyYamlContext context)
        {
            // TODO: Apply Go Templating to the YAML file/contents
            return States;
        }

        public IList<AfyYamlAction> GetStateTransitionActions(AfyYamlContext context, object sourceYamlDef)
        {
            return AfyConstants.EmptyActionList;
        }
    }

    public class ImportMetaFragmentDefinition
    {
        /// <summary>
        /// The fragment file path
        /// </summary>
        [YamlMember(Order = 1)]
        public string Path { get; set; }

        /// <summary>
        /// Optional list of variables provided to the template model when importing from this fragment
        /// </summary>
        [YamlMember(Order = 2)]
        public List<FragmentVarDefinition> Vars { get; set; } = new List<FragmentVarDefinition>();

        [YamlIgnore]
        public MetaFragmentDefinition Fragment { get; internal set; }
    }

    /*
    public class MetaFragment : AfyStateContainer
    {
        public string Name { get; internal set; }

        public Dictionary<string, string> Metadata { get; } = new Dictionary<string, string>();

        public string StateNamePrefix { get; internal set; }
        public string FragmentInitState { get; internal set; }

        public List<AfyNavRouteDefinition> NavRoutes { get; } = new List<AfyNavRouteDefinition>();

        public List<AfyState> States { get; } = new List<AfyState>();

        public MetaFragment(string name) { Name = name; }

        public IList<AfyState> GetStates(AfyYamlContext context)
        {
            // TODO apply templating to state fragment afy file
            return States;
        }


    }
    */

    #endregion Meta Fragments

    #region State Fragments

    public class StateFragmentDefinition : AfyStateContainer
    {
        /// <summary>
        /// Logical name for this state fragment, must be unique across all meta and state fragments imported into the parent meta/afy
        /// </summary>
        [YamlMember(Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// If the group of states / the encapsulated logic requires meta-level variable initialization, then a state name can be provided in this
        /// field, and assuming that the top-level MetaDefinition has an `InitState` defined, this state will be called one time only when the meta
        /// starts.
        /// 
        /// NOTE:
        /// This state *MUST* eventually reach the last rule which is managed by the `InitState` generation process, which will append a file rule to
        /// the `FragmentInitState` to `SetState` to the next `InitState`
        /// </summary>
        [YamlMember(Order = 2)]
        public string FragmentInitState { get; set; } = "";

        /// <summary>
        /// Optional string to prefix all states defined in the States property, if any.
        /// </summary>
        [YamlMember(Order = 3)]
        public string StateNamePrefix { get; set; } = "";

        /// <summary>
        /// Optional list of named variables and corresponding values that will be included in the templateable variables if no specific `Vars` entry with
        /// the same name is provided when importing the fragment in the `ImportFragment` directive
        /// </summary>
        [YamlMember(Order = 3)]
        public List<FragmentVarDefinition> DefaultVars { get; internal set; } = new List<FragmentVarDefinition>();

        /// <summary>
        /// List of complete meta states that are needed in order for this state fragment to function as intended.
        /// </summary>
        [YamlMember(Order = 4)]
        public List<AfyState> States { get; set; } = new List<AfyState>();

        /// <summary>
        /// Sections of this state fragment that are imported into concrete states in the meta itself using the ImportFragment action.
        /// </summary>
        [YamlMember(Order = 5)]
        public List<StateFragmentSectionDefinition> Sections { get; set; } = new List<StateFragmentSectionDefinition>();

        /// <summary>
        /// optional list of named nav routes that can be referenced in any `EmbedNav` Action.
        /// </summary>
        [YamlMember(Order = 6)]
        public List<AfyNavRouteDefinition> NavRoutes { get; set; } = new List<AfyNavRouteDefinition>();

        public IList<AfyState> GetStates(AfyYamlContext context)
        {
            // TODO apply templating to state fragment afy file
            return States;
        }

        public IList<AfyYamlAction> GetStateTransitionActions(AfyYamlContext context, object sourceYamlDef)
        {
            // TODO ADD SUPPORT FOR THIS!!
            ImportFragment importFragDirective = sourceYamlDef as ImportFragment;
            // importFragDirective.

            return AfyConstants.EmptyActionList;
        }
    }

    public class StateFragmentSectionDefinition
    {
        /// <summary>
        /// The name of this section, referenced in the ImportFragment directive
        /// </summary>
        [YamlMember(Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// Standard ordered list of rules that will be imported, in place, when the ImportFragment directive is used in a State rule list
        /// in the top-level meta
        /// </summary>
        [YamlMember(Order = 2)]
        public List<AfyStateEntry> Rules { get; set; }

        /// <summary>
        /// List of variable names to call clearvar[] on when transitioning out of any state that imports this state section
        /// </summary>
        [YamlMember(Order = 3)]
        // TODO ADD SUPPORT FOR THIS!!
        public List<string> ClearVarsOnStateChange { get; set; } = new List<string>();
    }

    public class ImportStateFragmentDefinition
    {
        /// <summary>
        /// Name for this fragment, referenced by the ImportFragment directive
        /// </summary>
        [YamlMember(Order = 1)]
        public string Name { get; set; }

        /// <summary>
        /// The fragment file path
        /// </summary>
        [YamlMember(Order = 2)]
        public string Path { get; set; }

        /// <summary>
        /// Explicit list of section names that are inside the State Fragment and are able to be referenced in the `ImportFragment` directive.
        /// 
        /// NOTE: If no section names are provided, the Section name *MUST* be `Default` in the Fragment file, which will be validated at a later point in
        /// the reading or generation process
        /// </summary>
        [YamlMember(Order = 3)]
        public List<string> Sections { get; set; }

        /// <summary>
        /// Optional list of named variables and corresponding values that will be included in the templateable variables if no specific `Vars` entry with
        /// the same name is provided when importing the fragment in the `ImportFragment` directive
        /// </summary>
        [YamlMember(Order = 4)]
        public List<FragmentVarDefinition> DefaultVars { get; internal set; } = new List<FragmentVarDefinition>();

        /// <summary>
        /// optional list of `var` names that must be cleared if any rules generated by this fragment would transition to another state.
        /// </summary>
        [YamlMember(Order = 5)]
        // TODO ADD SUPPORT FOR THIS!!
        public List<string> ClearVarsOnStateChange { get; internal set; } = new List<string>();

        /// <summary>
        /// optional list of `pvar` names that must be cleared if any rules generated by this fragment would transition to another state.
        /// </summary>
        [YamlMember(Order = 6)]
        // TODO ADD SUPPORT FOR THIS!!
        public List<string> ClearPVarsOnStateChange { get; internal set; } = new List<string>();

        [YamlIgnore]
        public StateFragmentDefinition Fragment { get; internal set; }
    }

    #endregion State Fragments

}
